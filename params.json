{"name":"Jdbcspy","tagline":"Automatically exported from code.google.com/p/jdbcspy","body":"The jdbcspy is a lightweight profiling and monitoring proxy for your jdbc connection. It can be configured very easily and will provide information, which statements are executed, what are the statements with the longest duration, additional statistics about your connections, what statements are executed how often, etc. In addition it is possible to extend the proxy by implementing custom listeners that will provide additional information.\r\n\r\n= Features =\r\n\r\n  * log the execution and the iteration time of all SQL statements\r\n  * identify statements that are executed multiple times\r\n  * the stack trace with configurable depth for all listed statements\r\n  * provides statistics for all connections, SQL statements, resultsets\r\n  * provides the size of the resultset\r\n  * provides an API to retrieve all statistical information\r\n  * list all statements that are currently being executed\r\n  * list all statements that have been executed, but have not been closed\r\n  * notifies (e.g. via trace) if a statement's execution time exceeds a configurable threshold\r\n  * notifies if you forgot to close a resultset, or a statement before the connection is closed\r\n  * supports different loggers (log4j, java logging, slf, ...)\r\n  * extendable by custom listeners\r\n\r\n= Installation =\r\n\r\nThe installation is quite easy.\r\n  # copy the file jdbcspy.jar into your classpath\r\n  # copy the dbproxy.xml file into your home drive and edit the driver class name of the underlying jdbc driver. In addition you may want to configure the driver. Detailed information is [http://code.google.com/p/jdbcspy/wiki/Configuration here].\r\n  # To the normal database url, you have to add the prefix _proxy:_\r\n  # Now you can start your application as usual. The proxy will be activated and gather information about your jdbc connection.\r\n\r\n= User Guide (5min) =\r\n\r\nTry the following code (taken from the junit testclass MyTest.minimal() -\r\ncmp source code):\r\n\r\n{{{\r\n\t// register the proxy driver\r\n\tClass.forName(\"de.luisoft.jdbcspy.DBProxyDriver\");\r\n\r\n\t// get a connection in the usual manner. Please add the prefix\r\n\t// 'proxy:' to the driver url\r\n\t// The mytestdb driver is a mock database. The statement below\r\n\t// will return 100 result sets and takes 1000ms(500ms)\r\n\t// to iterate(execute) the result set\r\n\tConnection c = DriverManager.getConnection(\r\n\t\t\"proxy:mytestdb&rscnt=100&itertime=1000&exectime=500\");\r\n\r\n\tPreparedStatement p = c.prepareStatement(\"select * from test\");\r\n\tResultSet rs = p.executeQuery();\r\n\r\n\twhile (rs.next()) {\r\n\t\t// read result set\r\n\t}\r\n\trs.close();\r\n\tp.close();\r\n\tc.close();\r\n}}}\r\n\r\nThe following information is determined by the jdbcspy:\r\n\r\n{{{\r\n[ExecutionTimeListener[\r\ncurrently executing:\r\n\r\nexecuted but waiting to be closed:\r\n\r\nlong running history (execTime + iterTime):\r\n1: \"select * from test\" (501ms + 1.0s; #=100) executed since 21:54:58.894 in MyTest.minimal:95|TestCase.runTest:166|TestCase.runBare:140\r\n]]\r\n\r\n[ExecutionLastStatementListener[\r\n0: \"select * from test\" (#=1, MyTest.minimal:95|TestCase.runTest:166|TestCase.runBare:140)\r\n]]\r\n\r\n[ExecutionRepeatCountListener[\r\n1: #=1: \"select * from test\"\r\n]]\r\n\r\n[ExecutionStatisticListener[online since 21:54:58 (1.65s)\r\n#stmt=1; #rs=100; duration=1.51s; avgDuration=1.51s; maxLength=18; avgLength=18;\r\ntime={1-3s}=1;\r\nlength={<=20}=1\r\n]]\r\n\r\n\r\n[ConnectionStatisticListener[\r\n#conn=1; #max open conns=1; #max stmts/conn=1\r\n]]\r\n}}}\r\n\r\nHow do I have to interpret the data?\r\n\r\n=== ExecutionTimeListener ===\r\n\r\nThe ExecutionTimeListener provides information about the statement execution times and maintains a statistic about the long running statements.\r\n\r\nFirst of all it informs you that neither a statement is currently being executed nor a statement that has been executed is waiting to be closed.\r\nThe 'long running history' lists all statements sorted by the execution time. For each statement the following information is provided:\r\n  * the execution time (501ms - 1ms overhead), which is the time that the database needs to return the first result set.\r\n  * the iteration time (1s), which is the time the database needs to return the resultsets 2 to n\r\n  * and the size of the resultset (100)\r\n  * the time when the execution/query has been started\r\n  * the (simplified) stacktrace (including class, method and line number) to track the statements initiator\r\n\r\n{{{\r\n1: \"select * from test\" (501ms + 1.0s; #=100) executed since 21:54:58.894 in MyTest.minimal:95|TestCase.runTest:166|TestCase.runBare:140\r\n}}}\r\n\r\n=== ExecutionLastStatementListener ===\r\n\r\nList the last statements that have been executed. In our example there is only one statement. The #1 means, that this statement has been executed only once.\r\n\r\n{{{\r\n0: \"select * from test\" (#=1, MyTest.minimal:95|TestCase.runTest:166|TestCase.runBare:140)\r\n}}}\r\n\r\n=== ExecutionRepeatCountListener ===\r\n\r\nList the statements that have been executed multiple times ordered by their occurrence.\r\n\r\n{{{\r\n1: #=1: \"select * from test\"\r\n}}}\r\n\r\n=== ExecutionStatisticListener ===\r\n\r\nThe ExecutionStatisticListener provides statistical information about the SQL statements.\r\nYou get the following information:\r\n  * 1 statement has been executed\r\n  * the sum of all resultset sizes for all statements is 100\r\n  * the maximum and average duration (sum of execution and iteration times for all statements) is 1.50s\r\n  * the maximum and the average length (serialized all resultset attributes) of the resultset is 18byte\r\n  * there is one statement in the execution time range from 1 to 3 seconds\r\n\r\n{{{\r\n#stmt=1; #rs=100; duration=1.50s; avgDuration=1.50s; maxLength=18; avgLength=18;\r\ntime={1-3s}=1;\r\nlength={<=20}=1\r\n}}}\r\n\r\n=== ConnectionStatisticListener ===\r\n\r\nThe ConnectionStatisticListener provides statistical information about the connections.\r\n\r\nYou get the following information:\r\n  * 1 connection has been opened\r\n  * maximum 1 connection has been open concurrently\r\n  * maximum 1 statement has been opened per connection\r\n\r\n{{{\r\n#conn=1; #max open conns=1; #max stmts/conn=1\r\n}}}\r\n\r\nFor more complex examples you may have a look at the junit tests that are provided with the distribution or checkout the project.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}